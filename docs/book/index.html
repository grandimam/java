<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basics</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html" class="active"><strong aria-hidden="true">1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Collections</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Generics</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> IO</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Streams</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> OOPS</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Java platforms has tools and libraries necessary for developing Java based application. </p>
<p>JVM and JRE are core components of JDK. JVM is the run-time engine to run the Java application. JVM calls the main method. 
Java applications are called WORA (write once read anywhere). A programmer can develop Java code on one system and expect
to run on any other environment. When we compile a .java file, a .class file gets created by the Java compiler. The <em>.class</em> 
files contains byte-code with the same class names present in <em>.java</em>. </p>
<p>These class files go through various stages -</p>
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign20-min-1.png" alt="" /></p>
<h3 id="jit-just-in-time-compilation"><a class="header" href="#jit-just-in-time-compilation"><strong>JIT (Just In Time Compilation)</strong></a></h3>
<p>Just-in-time (JIT) compilation is a way of executing computer code that involves compilation during execution of a program (runtime).</p>
<p>Converting bytecode to native machine language has a huge impact. These Bytecode have to be interpreted or compiled to proper machine instructions depending on the instruction set architecture. </p>
<p>Moreover, these can be directly executed if the instruction architecture is bytecode based. Interpreting the bytecode affects the speed of execution. In order to improve performance, JIT compilers interact with the Java Virtual Machine (JVM) at run time and compile suitable bytecode sequences into native machine code.</p>
<h1 id="data-type"><a class="header" href="#data-type">Data Type</a></h1>
<p>Java is strictly pass by value. </p>
<p>In pass by value, the caller and callee method operate on two difference variables which are copies of each other. Any 
changes on the one won't modify the other. While calling the method, the parameters are passed will be clone of the 
original parameters. Any modification done won't have any effect on the original parameters.</p>
<p>In pass by reference, the caller and callee method will operate on the same object. Any changes on the parameter will 
result in changes of the original value. Primitives variables store the actual value, non-primitive variables store reference</p>
<p>There are two broad data types - primitive and reference. Primitive data types are the basic data types. In Java, the 
primitive data types are integer, floating-point, character, and boolean. Reference data types are object that contains 
references to value or other objects.</p>
<p><strong>Declaring the primitive data types</strong></p>
<pre><code class="language-java">int a;
int b;
</code></pre>
<p>The variables will receive default values based on their declared types. For integers, the default values would be 0, and 0.0.</p>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>An array is a reference type that can store collections of specific type. Arrays are objects and object variables are 
always references in Java. So, when we declare an object variable as final, it means that the variable cannot be changed
to refer to anything else.</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>An object whose state remains constant after it has been created entirely. Once an object has been assigned to a variable,
we can neither update the reference nor mutate the internal state.</p>
<p>String are created immutable, thread-safe to improve caching and performance. String uses a process called interning, 
where we store only one distinct copy of the value and reusing them to save heap (two different variables point to the 
same string object).</p>
<h3 id="string-buffer-and-string-builder"><a class="header" href="#string-buffer-and-string-builder">String Buffer and String Builder</a></h3>
<ul>
<li>String are immutable, and objects of StringBuffer and StringBuilder are mutable.</li>
<li>StringBuffer and StringBuilder are similar, but StringBuilder is faster and preferred over StringBuffer for single-threaded program. If thread safety is needed, then StringBuffer is used.</li>
</ul>
<h3 id="-comparison"><a class="header" href="#-comparison"><strong>==, comparison</strong></a></h3>
<p>This way of string comparison only checks for referential equality of two string.</p>
<pre><code class="language-java">String string1 = &quot;using comparison operator&quot;;
String string2 = &quot;using comparison operator&quot;;
String string3 = new String(&quot;using comparison operator&quot;);

assertThat(string1 == string2).isTrue();
assertThat(string1 == string3).isFalse();
</code></pre>
<p>In the example above, the first assertion is true because the two variables point to the same <em>String</em> literal. On the other hand, the second assertion is false because <em>string1</em> is created with a literal and <em>string3</em> is created using the <em>new</em> operator – therefore they reference different objects.</p>
<h3 id="equals"><a class="header" href="#equals"><strong>equals()</strong></a></h3>
<p>Equals is overriden by the String class from the Object. This method compares two strings character by character ignoring their address.</p>
<pre><code class="language-java">String string1 = &quot;using equals method&quot;;
String string2 = &quot;using equals method&quot;;

String string3 = &quot;using EQUALS method&quot;;
String string4 = new String(&quot;using equals method&quot;);

assertThat(string1.equals(string2)).isTrue();
assertThat(string1.equals(string4)).isTrue();

assertThat(string1.equals(null)).isFalse();
assertThat(string1.equals(string3)).isFalse();
</code></pre>
<p>In this example, <em>string1, string2,</em> and <em>string4</em> variables are equal because they have the same case and value irrespective of their address.</p>
<p>For <em>string3</em> the method returns <em>false,</em> as it's case sensitive. Also, if any of the two strings is <em>null</em>, then the method returns <em>false.</em></p>
<h3 id="equalsignorecase"><a class="header" href="#equalsignorecase"><strong>equalsIgnoreCase()</strong></a></h3>
<p>Ignores casing in characters while comparing <em>Strings</em>.</p>
<h3 id="compareto"><a class="header" href="#compareto"><strong>compareTo()</strong></a></h3>
<p>Compares two string character by character lexicographically. This method returns 0 if two <em>Strings</em> are equal or if both are <em>null,</em> a negative number if the first <em>String</em> comes before the argument, and a number greater than zero if the first <em>String</em> comes after the argument <em>String.</em></p>
<pre><code class="language-java">String author = &quot;author&quot;;
String book = &quot;book&quot;;
String duplicateBook = &quot;book&quot;;

assertThat(author.compareTo(book))
  .isEqualTo(-1);
assertThat(book.compareTo(author))
  .isEqualTo(1);
assertThat(duplicateBook.compareTo(book))
  .isEqualTo(0);
</code></pre>
<h1 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h1>
<p>Access modifiers are used to encapsulate the state of the objects. Default access modifiers are package-private, as all 
members are only visible within the same packages. Protected access modifiers are also package-private but also members 
are visible to their subclasses as well.</p>
<h2 id="variable-scope"><a class="header" href="#variable-scope">Variable Scope</a></h2>
<p><strong>Instance and Class Variable</strong></p>
<p>Instance and class variables don't require us to initialize. As soon as we declare them they are given default value.</p>
<pre><code class="language-java">@Test
public void whenValuesAreNotInitialized_thenUserNameAndIdReturnDefault() {
    User user = new User();

    assertThat(user.getName()).isNull();
    assertThat(user.getId() == 0);
}
</code></pre>
<p><strong>Local Variable</strong></p>
<p>Local variable must be initialized before use, as they don't have default value. The below code will give error during 
the compilation stage itself.</p>
<pre><code class="language-java">public void print(){
    int i;
    System.out.println(i);
}
</code></pre>
<p><strong>Final</strong></p>
<p>Final variable is applied to the field that can no longer be modified.</p>
<h2 id="non-access-modifiers"><a class="header" href="#non-access-modifiers">Non-Access Modifiers</a></h2>
<ul>
<li>
<p>Final</p>
</li>
<li>
<p>Static</p>
</li>
<li>
<p>Volatile</p>
</li>
<li>
<p>Abstract</p>
</li>
<li>
<p>Transient</p>
</li>
<li>
<p>Synchronized</p>
</li>
</ul>
<h2 id="static"><a class="header" href="#static">Static</a></h2>
<p>Static keyword means that a particular member belongs to the type itself rather than the instance of that type. That is 
there is only one instance of the member shared across all instances of the class. Static initializers are created 
before the class is created. </p>
<p><strong>Fields</strong></p>
<p>Static fields are stored in the heap. When a field is declared as static, a single copy of that field is created and 
shared among all instance of that class. Static fields can only be declared at a class level, and can be accessed 
without object creation.</p>
<pre><code class="language-java">public class Car {
    private String name;
    private String engine;

    public static int numberOfCars;

    public Car(String name, String engine) {
        this.name = name;
        this.engine = engine;
        numberOfCars++;
    }

    // getters and setters
}
</code></pre>
<p><strong>Methods</strong></p>
<p>Static methods belong to the class instead of the instance. We can call them without creating the object. Static methods
are resolved in compile time and since overriding is runtime process static methods cannot be overridden. Abstract methods
cannot be static. Static methods can't use this or super. Instance methods can directly access other instance and 
non-instance methods and variables. Static methods can access all static variables, methods and can't access non-static 
variables and methods directly (they require object reference to do so)</p>
<p><strong>Class</strong></p>
<p>A class can be made <strong>static</strong> only if it is a nested. We cannot declare a top-level class with a static modifier. Such 
types of classes are called Nested static classes. Nested static class doesn’t need a reference of Outer class. </p>
<p>In this case, a static class cannot access non-static members of the Outer class.</p>
<h2 id="final"><a class="header" href="#final">Final</a></h2>
<p>Final keyword is used to limit the scope for variables, classes, and methods.</p>
<p><strong>Class</strong></p>
<p>Classes market with final keyword cannot be extended. One of the major immutable classes that have final marked are 
String class. Any attempt to extend a final class will result in compilation error. Final class doesn't mean that objects
are immutable. We just can't extend it.</p>
<pre><code class="language-java">public final class Cat {

    private int weight;

    // standard getter and setter
}
</code></pre>
<p><strong>Methods</strong></p>
<p>Methods marked as finals cannot be overriden.</p>
<pre><code class="language-java">public class Dog {
    public final void sound() {
        // ...
    }
}
</code></pre>
<ul>
<li>Methods marked as final can be overloaded</li>
<li>Mark a method as final if we don't want to the caller to cause suprising results</li>
<li>Difference between marking all the methods final and marking the class final is that in the former we can extend the 
class and in the latter we cannot</li>
</ul>
<p><strong>Fields and Variables</strong></p>
<p>Variables marked as final cannot be reassigned. Primitive variables cannot be assigned again. Reference variables cannot
be reassigned but are still mutable.</p>
<pre><code class="language-java">final Cat cat = new Cat();
</code></pre>
<pre><code>cat.setWeight(5);

assertEquals(5, cat.getWeight());
</code></pre>
<p>Final fields can be constant or write once fields. And class constant fields should be capitalized. In case the fields 
are not meant to be serialized then the fields must be specified as final.</p>
<pre><code class="language-java">static final int MAX_WIDTH = 999;
</code></pre>
<p>All final fields must be initialized before the constructor completes. <strong>You can assign a value to a final variable only one time.</strong></p>
<ul>
<li>For static final fields, these need to be initialized upon declaration or inside static initializers (as static 
initializers are created before constructors).</li>
<li>For instance fields, they can be initialized - upon declaration, inside initializer block, inside the constructor.</li>
</ul>
<p>Constructor can be invoked only <strong>one</strong> time per object creation by using the <code>new</code> keyword. You cannot invoke constructor multiple times, because constructor are not designed to do so.</p>
<pre><code>class Test {
    private final List foo;

    public Test() {
        foo = new ArrayList();
        foo.add(&quot;foo&quot;); // Modification-1
    }

    public void setFoo(List foo) {
       //this.foo = foo; Results in compile time error.
    }
}
</code></pre>
<p><code>foo</code> is an <strong>instance</strong> variable. When we create <code>Test</code> class object then the instance variable <code>foo</code>, will be copied 
inside the object of <code>Test</code> class. If we assign <code>foo</code> inside the constructor, then the compiler knows that the constructor
will be invoked only once, so there is no problem assigning it inside the constructor.</p>
<p>If we assign <code>foo</code> inside a method, the compiler knows that a method can be called multiple times, which means the value
will have to be changed multiple times, which is not allowed for a <code>final</code> variable. So the compiler decides constructor
is good choice!</p>
<p><strong>Argument</strong></p>
<p>Final argument cannot be changed inside the method</p>
<pre><code class="language-java">public void methodWithFinalArguments(final int x) {
    x=1;
}
</code></pre>
<p>The final local variable x cannot be assigned. It must be blank and not using a compound assignment.</p>
<p><strong>Static - Final</strong></p>
<p>These fields need to be initialized upon declaration or inside static initializers.</p>
<pre><code class="language-java">private static final List foo = new ArrayList();
</code></pre>
<p><code>foo</code> is now a <strong>static</strong> variable. When we create an instance of <code>Test</code> class, <code>foo</code> will not be copied to the object 
because <code>foo</code> is static. Now <code>foo</code> is not an independent property of each object. This is a property of <code>Test</code> class. 
But <code>foo</code> can be seen by multiple objects and if every object which is created by using the <code>new</code> keyword which will 
ultimately invoke the <code>Test</code> constructor which changes the value at the time of multiple object creation (Remember 
<code>static foo</code> is not copied in every object, but is shared between multiple objects)</p>
<h2 id="synchronized"><a class="header" href="#synchronized">Synchronized</a></h2>
<p>Race condition occurs when two or more thread attempt to update shared data. We can avoid this by synchronized thread access to the shared data, allowing only one thread to execute at any given time. </p>
<p>Synchronized keyword can be used across - </p>
<ul>
<li>
<p>instance methods</p>
</li>
<li>
<p>static methods</p>
</li>
<li>
<p>code blocks</p>
</li>
</ul>
<p>Synchronized internally uses a monitor lock to provide synchronization. The monitors are bound to an object, and all synchronized blocks of the same object can have only one thread executing them at the same time. </p>
<p><strong>Synchronized instance methods</strong></p>
<pre><code class="language-java">public synchronized void synchronisedCalculate() {
    setSum(getSum() + 1);
}
</code></pre>
<p>Instance methods are <em>synchronized</em> over the instance of the class owning the method, which means only one thread per instance of the class can execute this method.</p>
<p><strong>Synchronized static methods</strong></p>
<pre><code class="language-java">public static synchronized void syncStaticCalculate() {
     staticSum = staticSum + 1;
 }
</code></pre>
<p>These methods are synchronized on the class objects. Since only one <em>Class</em> object exists per JVM per class, only one thread can execute inside a <em>static</em> <em>synchronized</em> method per class, irrespective of the number of instances it has.</p>
<p><strong>Synchronized blocks within the methods</strong></p>
<pre><code class="language-java">public void performSynchronisedTask() {
    synchronized (this) {
        setCount(getCount()+1);
    }
}
</code></pre>
<p>This is the monitor object. The code inside the block gets synchronized on the monitor object. Simply put, only one thread per monitor object can execute inside that block of code. If the method was <em>static</em>, we would pass the class name in place of the object reference, and the class would be a monitor for synchronization of the block:</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next" href="chapter_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next" href="chapter_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
